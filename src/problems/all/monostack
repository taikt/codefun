>Practice

https://leetcode.com/problems/number-of-valid-subarrays/

https://codepro.lge.com/exam/19/overseas-questions-for-previous-test/quiz/9
https://leetcode.com/problems/remove-duplicate-letters/description/
https://leetcode.com/problems/remove-k-digits/description/
https://leetcode.com/problems/maximal-rectangle/description/
/*
https://leetcode.com/problems/remove-duplicate-letters/editorial/

Time complexity : O(N). Although there is a loop inside a loop, the time complexity is still O(N). This is because the inner while loop is bounded by the total number of elements added to the stack (each time it fires an element goes). This means that the total amount of time spent in the inner loop is bounded by O(N), giving us a total time complexity of O(N)
*/

// tim gan nhat ben phai < hien tai: dung stack tang, dk pop: h[top] > h[i]
// tim gan nhat ben phai <= hien tai: dung stack tang, dk pop: h[top] >= h[i]
// tim gan nhat ben phai > hien tai: dung stack giam, dk pop: h[top] < h[i]
// tim gan nhat ben phai >= hien tai: dung stack giam, dk pop: h[top] <= h[i]

partern: O(n)
for(int i=0;i<n;i++){
    while(!q.empty() && a[q.top()]>= a[i]){ // stack tang dan
        mark[q.top()]=i;//danh dau
        q.pop();
    }
    push(i);
}


int fn(vector<int>& arr) {
    stack<integer> stack;
    int ans = 0;

    for (int num: arr) {
        // for monotonic decreasing, just flip the > to <
        while (!stack.empty() && stack.top() > num) {
            // do logic
            stack.pop();
        }

        stack.push(num);
    }
}

// dang 2 cua monostack (tham lam): ko phai tim so lon hon, nho hon gan nhat
// https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/
partern: O(n)
for(int i=0;i<n;i++){
    while(!q.empty() && a[q.top()]>= a[i] && dk_them){ // stack tang dan
        //update thay doi(tac dong dk_them)
        q.pop();
    }
    push(i);
}