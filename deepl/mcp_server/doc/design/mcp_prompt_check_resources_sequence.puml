@startuml
' Step 10: For each C++ file, read its content
' Step 11: Parse each file to extract resource operations (open/close, etc.)
' Step 12: Build a resource flow map to track resource allocation/release flows across files
' Step 13: Create dynamic groups of files related by resource flows
' Step 14: Detect resource leaks based on the resource flow map and groups
' Step 15: Prepare AI context for complex resource leak cases
' Step 16: Generate summary and actionable recommendations
actor "Copilot Chat (client)" as copilot
box "MCP Server" #LightBlue
  participant "Controller" as controller
  participant "PromptHandler" as promptHandler
  participant "Tool Handler" as toolHandler
  participant "ResourceAnalyzer" as resourceAnalyzer
end box
participant "Storage" as storage #yellow

autonumber
copilot -> controller : get_prompt (check_resources, arguments)
controller -> promptHandler : handle_prompt("check_resources", arguments)
promptHandler -> toolHandler : _handle_ai_resource_analysis({dir_path})
toolHandler -> resourceAnalyzer : analyze_codebase(dir_path)
resourceAnalyzer -> storage : list_source_files(dir_path)
storage --> resourceAnalyzer : return list of C++ files
alt C++ files found
  loop for each C++ file
    ' Step 10: For each C++ file, read its content
    resourceAnalyzer -> storage : read file content
    storage --> resourceAnalyzer : return file content
    ' Step 11: Parse each file to extract resource operations (open/close, etc.)
    resourceAnalyzer -> resourceAnalyzer : parse_file(file_path)
  end
  ' Step 12: Build a resource flow map to track resource allocation/release flows across files
  note over resourceAnalyzer
     Build a resource flow map to track resource allocation/release flows across files
  end note
  resourceAnalyzer -> resourceAnalyzer : build resource flow map

  ' Step 13: Create dynamic groups of files related by resource flows
  note over resourceAnalyzer
     Create dynamic groups of files that are related by resource flows for further analysis.
     These files may operate on the same resource variable, or have linked open/close flows (e.g., one file opens, another file closes).
  end note
  resourceAnalyzer -> resourceAnalyzer : create dynamic groups

  ' Step 14: Detect resource leaks based on the resource flow map and groups
  note over resourceAnalyzer
     Detect resource leaks using the resource flow map and dynamic groups
  end note
  resourceAnalyzer -> resourceAnalyzer : detect resource leaks

  ' Step 15: Prepare AI context for complex resource leak cases
  note over resourceAnalyzer
     Prepare context and code snippets for AI-assisted analysis of complex resource leak cases
  end note
  resourceAnalyzer -> resourceAnalyzer : prepare AI context (complex cases)

  ' Step 16: Generate summary and actionable recommendations
  note over resourceAnalyzer
     Generate a summary and actionable recommendations based on the analysis results
  end note
  resourceAnalyzer -> resourceAnalyzer : generate summary & recommendations
  resourceAnalyzer --> toolHandler : return metadata (leaks, summary, groups, recommendations)
else No C++ files
  resourceAnalyzer --> toolHandler : return no files found
end
toolHandler --> promptHandler : return findings
promptHandler --> controller : return prompt (with findings)
controller --> copilot : return prompt (with findings)
@enduml
